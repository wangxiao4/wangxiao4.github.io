<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xiao4 800K</title>
    <link>http://www.wangxiao4.xyz/</link>
    <description>Recent content on Xiao4 800K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>版权所有©2019–2021，Xiao4 800K；保留所有权利。</copyright>
    <lastBuildDate>Thu, 25 Feb 2021 17:06:46 +0800</lastBuildDate><atom:link href="http://www.wangxiao4.xyz/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nginx玩法 — 负载均衡</title>
      <link>http://www.wangxiao4.xyz/blog/nginx_loadbalance/</link>
      <pubDate>Thu, 25 Feb 2021 17:06:46 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/nginx_loadbalance/</guid>
      <description>Nginx玩法 — 负载均衡 首先我们需要弄清楚负载均衡的含义，负载均衡是通过算法实现平均分配的策略，将数据交互平均分担到集群中的各个服务中，从而提高整体对外服务的可用性，健壮性和性能等。
负载均衡是Nginx中较为重要的功能，常用于站点级的负载策略之中，相对于使用专属硬件做负载，拥有维护方便，成本低等特点，所以在日常系统中Nginx做负载也是不错的选择。
举个例子 川菜馆里的多个厨子，为了能够快速响应客户的点餐吃饭的需求，通常需要多个厨子完成不同的菜品， 节省上菜的时间，一但一个厨师请了假，也不会有太大影响，因为有其他厨师顶替他的位置继续服务客户。 这在川菜馆就相当于负载均衡服务器，每个厨师是一个单独的服务  那么在Nginx中如何使用那？ 代码如下
upstream backend{ server http://127.0.0.1:8080/; server http://127.0.0.1:8081/; server http://127.0.0.1:8082/; } server{ listen 80; server_name localhost; location / { proxy_pass backend; } }  将代码写入nginx.conf的http代码块中，nginx -s reload 一下，刷新界面看看效果
主要命令包括
1. proxy_pass 用于指定服务组 2. upstream 用于定义服务组 3. listen 监听端口 4. server_name 指定服务名称 5. location 定义不同请求的处理  通过以上命令我们就可以快速搭建一个基于Nginx的负载均衡服务器，但是在我们使用中还需要注意到其他的问题 比如我们后端具有身份验证，那么我们轮询backend组中的服务就会出现问题，因为用户在其中一台中存放了身份信息，所以其他服务认为这是非法的操作。再比如每一台服务器都不一样，有的服务配置较高，有的较低，如果使用相同的访问量，必定对配置较低的服务器产生较大压力从而影响到数据的响应或直接宕机瘫痪，那么我们该如何避免这些问题那？接下来我们就看一下Nginx为我们提供的几个命令。
# weight = value 权重模式,权重越高，被访问到的几率越大 upstream backend1{ server http://127.0.0.1:8080/ weight=1; server http://127.0.0.1:8081/ weight=2; server http://127.</description>
    </item>
    
    <item>
      <title>Nginx玩法 — 反向代理</title>
      <link>http://www.wangxiao4.xyz/blog/reverseproxy/</link>
      <pubDate>Thu, 25 Feb 2021 14:27:56 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/reverseproxy/</guid>
      <description>Nginx玩法 — 反向代理 Nginx的反向代理是一块比较常用且重要的功能，查看一下关于反向代理的指令，你就体会到有多重要了，否则也不会给出20+的指令，翻看一下在上一篇正向代理用到的指令，一个手的就能数的完了。
那么在开始愉快玩耍之前还是要先搞清楚，这个反向代理到底是什么意思。
举个例子  有这么一天，狐朋带着狗友，去市区中心吃饭，由于这地段只有这一家川菜馆，所以生意火爆,川菜馆事先将常见的菜品都准备好， 但是依然无法满足需求量，川菜馆就雇佣了多个大厨，这些大厨手艺有高有低，其中有一个大厨外号“盐不要钱”，恰好给狐朋狗友做菜的就是他， 狐朋狗友吃了这菜后，差点没过去，如果不是餐馆经理拦着估计就是给“盐不要钱”一顿好果子，最终餐厅辞退了“盐不要钱”， 狐朋狗友将剩菜剩饭打包后带走  我们可以将狐朋和狗友看作是客户端，川菜馆看作是反向代理服务器，厨子们是最终的服务器，可以简单看作反向代理包含着最终服务器
特点 由上述例子可以看出反向代理的几个特点
1. 具有加速访问的功能（事先准备好常见的菜品） 2. 对客户端隐藏了真正的服务端（客户并不知道，哪个大厨做的） 3. 对服务器具有保护作用（餐厅工作人员屏蔽掉了狐朋狗友想打厨子的请求） 4. 具有信息增强和筛选的功能（将不同的菜品分给凉菜师傅和热菜师傅，口味还要看师傅心情）  使用 简单的Hello World，将代码嵌入到 http 代码块中即可。
server{ listen 80; server_name localhost; location / { porxy_pass http://127.0.0.1:8080; } }  我们看一下这几个参数：
1. listen 代理监听的端口号，根据自己的情况编写即可 2. server_name 服务名称用于匹配请求，也可以写成自定义的域名，但需要额外的映射配置 3. location 监听全部请求，根据需求追加修改规则 4. proxy_pass 配置被代理地址可以是ip也可以是主机名称，还可以是upstream(后续说到)  这样我们一个基础的反向代理就搭建完成了，nginx -s reload 重新加载配置后，试着跑一下
这样我就看到了代理的 tomcat ，再查看一下我们的日志
扩充 接下来我们再看一下反向代理常用的一些指令
 proxy_pass upstream 通常我们会开启多个服务提高系统的可用性，在nginx中通过定义upstream将多个服务划分为一个组供代理使用，同时还可以设置模式，常见有顺序模式，权重模式和哈希模式，就是再原有基础上增加参数即可具体可参考其他博文的写法 信息头和信息主体的指令， .</description>
    </item>
    
    <item>
      <title>Nginx玩法 — 正向代理</title>
      <link>http://www.wangxiao4.xyz/blog/nginx_proxy/</link>
      <pubDate>Tue, 23 Feb 2021 17:19:13 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/nginx_proxy/</guid>
      <description>Nginx玩法 — 正向代理 正向代理
你请求代理帮你完成某件事情，代理将办理结果通知回你，类似于fan个qiang，访问谷歌，或者VPN。
举个例子比如：
你去商店买了一瓶水，店员直接卖给你一瓶，这中间没有任何其他参与者，你和店员之间就相当于没有代理  相反
如果你在打游戏，拜托你的朋友帮你买一瓶农夫山泉，朋友借此去市区见狐朋，到市区买了他最爱的运动耳机， 和狐朋吃了个饭并吐槽了一下要带水回去后，打包了剩菜剩饭，胡朋从河边灌了一瓶水，朋友带回来给你，最终你获得了一瓶水和晚饭。  这里可以将你看作客户端，狐朋狗友看作是代理，买一瓶农夫山泉是你的请求，狐朋狗友的一系列操作是数据传递和处理的过程
通过上面的例子，我们可以大概知道正向代理的几个特点
 1. 代理在客户端与终端之间 2. 对客户端屏蔽了终端的具体实现 （你不知道水是哪里买到的，也不知道最终是由谁完成的，你并不清楚是胡朋在河边灌的水） 3. 隐藏了客户端对终端的身份	（胡朋并不知道你的存在） 4. 可以帮你绕过限制达到最终目的（你在打游戏，无法自己去买水） 5. 具有信息过滤和加强的功能（朋友去除了你想要农夫山泉的数据，还给你带了晚饭） 6. 可以加速结果返回（如果朋友接收到要水的请求直接到厨房倒了一杯给你的话会节省很多时间）  使用 用到的属性有
1. resolver 这里可以根据自己的需求修改DNS 2. listen 配置监听的端口号 3. location 如果有个别路径需要特殊处理，可以适当增加规则 4. proxy_pass 这里通常时不变的  关键代码如下
server { resolver 8.8.8.8;	listen 80;	location / { proxy_pass http://$http_host$request_uri;	} }  将上述代码嵌入到 nginx.conf 的 http 代码块中即可
测试 可以使用火狐浏览器做测试，设置代理为Nginx的IP和端口
设置成功后访问网址都会在日志文件中有记录
Nginx常用命令 1. nginx -v	|	简洁版版本信息 2.</description>
    </item>
    
    <item>
      <title>抓各种页面数据</title>
      <link>http://www.wangxiao4.xyz/blog/baidu3/</link>
      <pubDate>Fri, 19 Feb 2021 10:14:45 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/baidu3/</guid>
      <description>新年刚过，还没从假期的懒散状态缓过来，就开始上班了，伸个懒腰，各位新年快乐~
百度？？？这篇算翻不过去了 朋友总是有很多奇怪的需求，这次他不但想要百度的数据，还希望抓更多其他搜索引擎的数据 针对朋友后面可能会有其他的需求，我想了以下几种方案
1. 割袍断义，绝交，这样以后都不会有任何需求了 2. 在原有基础上追加新引擎处理方法 3. 重构，将逻辑块封装后，外部脚本控制逻辑的扩展方式  综合当前情况，我并没有太多时间，并且要抓的数据又多种多样，我选择了第一种，并将想法告诉了朋友。 朋友发来了红包，我并不是那种认钱的人，我只是单纯喜欢解决问题而已，果断将红包退回，备注：* 老铁，你不了解我了 朋友很识趣，追加了个零后，又把红包发了过来。 想起这么多年的点点滴滴，大家都忙忙碌碌的，也没怎么好好聊过，也就是这情谊在这能让我们想起彼此，能帮一下就帮一下吧 我收下红包，嘴角洋溢着微笑
最终的效果 如何做 为了能够满足后期朋友那不断变化的需求，所以扩展性成为了首要关注点。 这次用使用C#作为开发语言，开门见山的说，可以通过使用反射加载DLL类库的形式，来扩展程序，但是一想到，这老铁也不会写代码 到后面肯定还是我来弄，所以我选择了更为有效的 Lua 脚本扩展方式，这样朋友这边可以自由追加修改，完成他的奇思妙想。
整理下思路 1. 将原程序的功能切分成更小的功能块 2. 将功能块暴漏给外部脚本 3. 测试原程序的功能块，并调整，使它更易调用 4. 编写Lua脚本 5. 测试脚本 6. 运行脚本  扬帆启航 由于之前并没有想后期变化的事情，所以代码基本上也是能用就ok的状态，那么首要决解的就是将功能拆分开来
而后需要将这些拆分好的功能块暴漏给Lua脚本才能用，这里需要注意库不同使用方法也有所差异
测试这些分散的功能块，并经是两种不同的语言，所以都会有方言的存在，保证整体逻辑的情况下修改成更易理解的方式
编写一下Lua脚本逻辑，并简单的测试一下
最终让代码像风一样自由的跑起来
代码可以根据上一篇代码基础上修改一下即可，这里就不放上来了，有点大。</description>
    </item>
    
    <item>
      <title>抓百度下拉框内容-续篇</title>
      <link>http://www.wangxiao4.xyz/blog/bdword/</link>
      <pubDate>Tue, 09 Feb 2021 11:16:44 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/bdword/</guid>
      <description>百度？？？你又要干嘛 朋友总是有很多奇怪的需求，由于之前给他的抓取方式并不是他心仪的方式，所以这他说如果很难的话就先不要弄了 作为一名身经百战的程序员，这无疑是赤果果的挑衅，那么咱们这次还是抓这个
那么咱们重新梳理一下思路
0. 打开电脑，打开浏览器 1. 让程序模拟用户操作，在浏览器的输入框中输入预存的词组 2. 截取当前浏览器的显示截图 3. 程序识别图中内容 4. 将内容保存到本地  如此往复1-4步 完成所有数据抓取
如何做  首先考虑浏览器问题  通常大厂的浏览器都会开放一些接口，可以帮助我们实现一些定制化的任务，但是通常都是通过脚本插件类型去完成， 但是考虑到有一些繁琐的操作在里面，这些接口可能并不够用，所以我认为将浏览器内嵌入程序中会更适合我们的操作
 如何内嵌那？  我使用了C#作为这个程序的编码语言，因为对我个人来说对C#的把控比其他语言更好一些，并且轮子也比较多，更符合快速响应的要求 内嵌浏览器并不是什么难事，.net平台本身有基于IE的浏览器控件可用，但是谁用谁知道，鸡肋的很，所以果断选择其他浏览器
 那么选择什么浏览器比较好？  无疑基于谷歌浏览器内核是首选的，为什么那？？？因为更喜欢谷歌😊 CefSharp Chromium-based browser 自行搜索该控件如何用吧
 图像识别  同样各种线上线下的都有很多，我们该如何选哪？商用并且不差钱当然首选大厂的库，方便快捷又卫生， 而且还有各种活动。自己做实验，用于玩具的当然希望接触的越多越底层越好。所以综合我们目前需求，选择了开源的OCR库。
1. chineseocr_lite 对中文内容更精准 2. Tesseract-OCR 也是不错的选择，人气高  我使用了chineseocr_lite，因为我希望我不需要再次训练它的情况下完成现在的任务
再次整理下思路 1. 开启程序 2. 程序自动加载网页 3. 网页加载完成后截图 4. 初始化所有环境 5. 输入预查询的内容 6. 截图 7. 识别 保存 8. 循环5-7至所有查询内容都处理完毕  扬帆启航 1. 整理所有需要用的库并简单测试 2.</description>
    </item>
    
    <item>
      <title>抓百度下拉框内容</title>
      <link>http://www.wangxiao4.xyz/blog/bddorpdown/</link>
      <pubDate>Sun, 07 Feb 2021 09:46:11 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/bddorpdown/</guid>
      <description>百度？？？你要干嘛 朋友总是有很多奇怪的需求，这次他想要百度搜索智能提示的内容，就是这个
至于他要干吗用，这个并没有太多去问，只是一时兴起，决定白嫖百度一下 开门见山的说，白嫖不好，如果大家有能力还是去购买相应的接口，等我有钱了就买百度云在抓数据😊
如何做 朋友给了我一个非常机智的方法
0. 打开电脑，打开浏览器 1. 让程序模拟用户操作，在浏览器的输入框中输入预存的词组 2. 截取当前浏览器的显示截图 3. 程序识别图中内容 4. 将内容保存到本地  至此完成一次操作，后续就是无限循环的抓取动作
我的想法就比较简单粗暴了，因为数据不可能缓存在本地，所以每次输入内容，百度一定会回服务器抓取的， 于是我打开浏览器，控制台监控浏览器的请求，发现了一些频率较高的重复Get请求，打开一看，哎嘿……这是啥
整理下思路 众所周知，百度引擎会爬各种网站的数据，所以爬虫对他们来说那是相当的熟悉，所以肯定会限制我们爬取他们 那么首要任务就是要测试这些Get请求是否有限制，最简单的方法直接PostMan测试一下，修改各种参数，头信息， 如果能够正常返回，剩下就是我们如何处理这些数据了
扬帆启航 0. 查找接口 1. 首先PostMan测试接口情况 2. 整理数据 3. 编写脚本 4. 运行测试 5. 简单压测   结果五根线程110词在2秒完成 ……666 最后附赠GO语言测试代码地址 csdn：https://download.csdn.net/download/at555444/15118651  </description>
    </item>
    
    <item>
      <title>谷歌浏览器代理如何玩</title>
      <link>http://www.wangxiao4.xyz/blog/chromeproxy/</link>
      <pubDate>Mon, 01 Feb 2021 11:14:08 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/chromeproxy/</guid>
      <description>谷歌浏览器代理如何玩 在我们玩爬虫的时候，通常需要访问大量的站点，而对百度或者谷歌这类搜索引擎对爬虫通常都有着很强的限制 比如当你的爬虫大量抓取百度的时候，百度会给你提示输入验证码等措施避免你频繁的访问， 当然想要解决这种问题，有很多种方法，比如使用代理，对目标站点隐藏自己的信息， 或者写对应的验证代码，通过验证限制
当然我认为使用代理是比较方便，且直接的方法 接下来就说说，我遇到的情况 首先先说一下这个小工具的目标，通过批量输入要查询的站点域名，查询域名在不同搜索引擎中的收录情况 包含：百度，谷歌，搜狗，360搜索，Archive 等
在经过测后发现，通常谷歌浏览器在同时开启50个搜索页面后，会有明显的卡顿，可能和我机器有一定的关系 但是无关紧要，关键的问题是，当同时开启50+的抓取行为后，上述的搜索引擎会弹出验证，这无疑增加了 操作人员的工作量，所以这就是我们现在要处理的问题之一，增加代理访问，绕过验证
在哪里增加，如何增加？  首先增加代理要在哪里增加哪？ 最开始我只发现了Archive在快速访问的时候会出现断开的问题，所以我想给这个站点增加一层代理， 也就是说针对这个站点有效的代理，市面上的各种代理，通常都是针对PC网卡端或浏览器进行监听并转发代理模式去操作 这明显和我的想要的不太一样，所以我准备镜像这个站点，快速的写了一些代码将它镜像做好，在镜像处理的同时增加一层代理 成功绕过限制后进行批量测试……百度首先发送了一个友好的验证码  我意识到可能需要在整体增加代理，在哪里增加比较合适那？无疑如果我在监听网卡可能会更麻烦，索性直接在Chrome浏览器增加算了 查看ChromeAPI 发现了有用的接口 1. &amp;ndash;proxy-server 启动命令中增加一个代理地址，但是由于我的访问量很大所以使用一个或多个并不起作用 2. pac文件	通过增加pac文件动态修改代理IP 这就很有意思了
 如何增加那？ 由于Chrome直接增加pac文件很麻烦，所以使用SwitchyOmega插件  安装SwitchyOmega插件，并打开管理面板 新建模式 选择PAC情景模式 创建模式，并选中 增加PAC脚本代码，据说是JS代码，并包含FindProxyForURL(url, host) 方法即可 测试一下 这时已经成功的设置了代理 你可以在脚本中写一些随机函数，让每一次请求都使用不同代理，也可以在PAC网址处增加动态获取接口 而我则使用了后者，因为这样使用起来更加方便，在工具中增加一个API用于提供PAC脚本，并在后台实时刷新可用的代理地址， SwitchyOmega插件中设置15分钟刷新一次PAC脚本，这样在基本上完成了代理的动态设置    不足之处 SwitchyOmega插件 最低刷新频率是15分钟，这里在某些层面上限制了代理的更换速率，可以通过修改插件完成自己想要的效果 不过对于我来说 还算够用
有些问题只有你自己经历了才会记忆深刻，多动手，多实验，总会找到办法 希望能对你有所帮助</description>
    </item>
    
    <item>
      <title>云服务器云空间那点事</title>
      <link>http://www.wangxiao4.xyz/blog/cloudspace/</link>
      <pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/cloudspace/</guid>
      <description>免费的服务器到底能不能用 目前市面上的免费服务器有很多，无论大厂小厂还是黑心作坊几乎都会推出一些免费的服务器 用于增加自己的客户量，抢占市场。 而多数小厂在没有知名度的情况下要么各种投放广告，要么就是降低用户投入成本，从而占有一席之地
目前来说也不能绝对否决小厂的服务器不好，的确我也碰到了一些还不错的厂商，接下来我就盘点一下我玩过的服务器
  八点云 推过一款云空间是免费的，关键是它还支持.net4.5，对于我这个.net方向来说那真是极好的 其他的感觉还不错，需要实名认证，但是需要备案，对于测试来说，还算够用了
  彩虹云 有一款美国免费空间，环境仅PHP/MySQL，并且月流量20G ，这是一个重点，它限流的 但是作为美国空间，当然也就无需备案喽
  三丰云 一款曾经给我无限遐想的厂商，超大的带宽超便宜的价格，而且还是北方线路， 免费主机算是推广续命版，月流量和数据库都很小，至少.vip和.xyz域名无法绑定，需要备案 还有坑爹的终身套餐，网评不太好，体验后总体来说有点弱，并没有官网描述的那么好
  我比较看重以下几点  各项参数，如空间大小，数据库大小，带宽等 空间地址，国外和香港地区，免备案会方便一点 续命周期和方式，不需要你发广告的已经算良心商家了，我见过最烦的一款是阿贝云的有多烦自己体验吧 稳定性，通常免费的空间都是用来测试，所以能找到一款相对稳定的算不错了  当然还有很多其他的厂商，大多是坑，如果有不错的请留言给我 相对来说，一分钱一分货，想好要一点的体验当然还是需要花一点钱
再来看几款相对来说性价比不错的云服务器   优刻得 用过一年的香港服务器，总体讲，首购入门版，做玩具很划算，有的时候远程桌面可能上不去 网络不稳定或调整的时候会给你发提示邮件，续费……真贵啊
  奇异互动 这一款我看了很久，因为想要做私服，所以特意看了这边的裸机和服务器，由于自身原因并没有过多体验 不过看一下价格 这带宽，这性能，这价格感觉可以后期尝试一下
  群英 老牌厂商，用了他家的高防大带宽服务器近一年的时间，对我而言感觉感觉相当不错了 虽然官方客服有时候让人很恼火，问问题可能要等很久才会回复你，或者索性就不回复了 但是管家这边还是很靠谱的，由于我买错服务器，在没有催的情况下大概半个月退了款 如果你需要开放WEB需要备案，就连IP访问也不行，不备案服务器再好你也玩不起来
  天翼云 活动期间找到一个低配置5M带宽的服务器，价格算是非常便宜了，加上一块100G数据盘也才190+/年 不过高带宽部分就相当贵了，同样WEB端口需要备案，自用的话可以用80，8080以外的端口 5M-10M可以考虑这个
  大厂 百度 腾讯 阿里云 华为云 这几个大厂都有自己活动，而且总会有几款入门的供你玩，也是相当不错的选择 而且新用户 大多有免费一个月半年的那种服务器，超值
  virmach 一款以便宜著称的厂商，网上会有各种优惠卷，各种教程，通常大家都是用它来科学上网的 用过一段时间，被墙了，想体验的可以试一下，很便宜</description>
    </item>
    
    <item>
      <title>关于《Go语言学习笔记》这本书</title>
      <link>http://www.wangxiao4.xyz/blog/gonote/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/gonote/</guid>
      <description>#关于《Go语言学习笔记》这本书
书如其名，真的算是一本笔记，书中大量篇幅都是代码块，文字介绍较少，基础理论内容也很少， 更多的是对某一些特性和一些用法上做实践，并且如果你细读的话也会发现一些写错的地方。 如果非要嗑这本书 建议先看一遍**《Go by Example 中文版》**，对基本使用和语法有一定了解后再嗑 笔者下卷部分并没有继续看，因为感觉还不到看源码的时候，所以再深造一段时间在回来看一下。 这里粗略的整理一下知识点，没时间看这本书，可以看一下笔者整理的部分，并不全，也只是针对笔者感兴趣的地方进行了整理   defer 延迟操作 无论函数是否发生异常 都会在return后执行 类型别名写法 type myInt = int 类型定义写法 type myInt int 注：类型定义与原始类型无关且不会继承原类型方法 需要强转后才能相互操作 不能前置自增 ++a 不能将自增作为表达式 if(a++)&amp;gt;0 const 常量不能使用取址操作 const a int -&amp;gt; &amp;amp;a 指针指向同一个地址 或者 都为 nil 两个指针相等 当给复合类型赋值时 需要遵守以下规则  必须带有类型名称 var a struct=struct{} {必须紧跟类型后 且在一行 值以 , 隔开 多行情况 尾值以, 或者} 结尾   使用 for range 的时候 for域内将会使用复制后的目标数据，for域内对目标数据操作 不会影响下一次取值，但会影响for域外的目标数据 使用 for range 后的参数如果是方法 那么该方法也只会获取一次 break continue 也可以像 goto 一样增加跳转位置 函数 不支持方法重载，不支持默认参数 ，支持多返回（这点很有意思） 函数采用值拷贝 包括指针类型也是 返回值命名后可以在方法体中当变量使用 最后直接return 无需带返回值 很方便 延迟调用 包括注册和调用，并增加额外的缓存开销，所以性能较直接调用偏低一点 panic和recover是 内置函数 类似于try catch 操作 panic 引发一个错误 recover读取最后一个错误。recover只能在延迟函数 defer 中使用 可以将string看作是byte数组，两者引用地址是相同的，string为只读类型，所以其操作大多需要重新分配内存地址，当有大量使用追加操作，损耗因能严重，并产生相当多的垃圾，建议使用strings.</description>
    </item>
    
    <item>
      <title>Createblog</title>
      <link>http://www.wangxiao4.xyz/blog/createblog/</link>
      <pubDate>Wed, 20 Jan 2021 15:59:43 +0800</pubDate>
      
      <guid>http://www.wangxiao4.xyz/blog/createblog/</guid>
      <description></description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://www.wangxiao4.xyz/about/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.wangxiao4.xyz/about/</guid>
      <description>&amp;mdash; Hi~ 欢迎你~ &amp;mdash;
我是王小4，一名coder 欢迎来到我的博文空间 我喜欢研究各种新鲜的东西，喜欢解决问题 可能和个人喜好有关系，接触的比较杂，常见的技术我都会去尝试玩一下。 这么多年过去了，这个行业改变了我很多，有好也有坏，如果上天再给我一次选择的机会，我……依然会选择软件 😀  &amp;mdash; 有啥 &amp;mdash;
1. 一些避坑记录 2. 开发语言使用教程 3. 技术分享 4. 开源小项目 5. 一些稀奇古怪的笔记  &amp;mdash; 提示 &amp;mdash;
如果有什么问题或建议，请立即马上联系我，作为技术人，我们应该具有分享精神，希望能和大家共同进步 当然并不仅限技术，都可以联系我，多个朋友，多个有趣的想法  &amp;mdash; 希望 &amp;mdash;
不负青春，不负时代 为了梦想 为了大瓦房 扬帆~启航~ 加油~奥里给~ </description>
    </item>
    
    <item>
      <title>发邮件给我</title>
      <link>http://www.wangxiao4.xyz/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.wangxiao4.xyz/contact/</guid>
      <description>发送</description>
    </item>
    
  </channel>
</rss>
